/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.11.0
 * Thu, 26 Feb 2026 14:37:51 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = new Map();
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();
_pGlob.css3Objects = new WeakMap();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function getSceneAnimFrameRate(scene) {
        if (scene && 'animFrameRate' in scene.userData) {
            return scene.userData.animFrameRate;
        }
        return 24;
    }
        
    function getSceneByAction(action) {
        const root = action.getRoot();
        let scene = root.type === 'Scene' ? root : null;
        root.traverseAncestors(ancObj => {
            if (ancObj.type === 'Scene') {
                scene = ancObj;
            }
        });
        return scene;
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        // COMPAT: <4.9.0, old engine, new puzzles
        const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable)
            objFound = _pGlob.objCache.get(objName);
    
        if (objFound && (isID ? objFound.uuid === objName : objFound.name === objName))
            return objFound;
    
        function findValidByName(obj, objName) {
            if ((isID ? obj.uuid === objName : obj.name === objName) && isObjectWorthProcessing(obj))
                return obj;
    
            for (let i = 0; i < obj.children.length; i++) {
                const child = obj.children[i];
                const object = findValidByName(child, objName);
                if (object !== null)
                    return object;
            }
    
            return null;
        }
    
        if (appInstance.scene) {
            objFound = findValidByName(appInstance.scene, objName);
            if (objFound && pGlobAvailable)
                _pGlob.objCache.set(objName, objFound);
        }
    
        return objFound;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }

    return {
        bindListener, getSceneAnimFrameRate, getSceneByAction, getObjectByName,
        retrieveObjectNames, transformCoordsSpace, getSceneCoordSystem,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    
    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["cargado"] = cargado;
this.procedures["inicio"] = inicio2;
this.procedures["continuar"] = continuar;
this.procedures["pegatina"] = pegatina;
this.procedures["respiradores"] = respiradores;
this.procedures["FIRMA"] = FIRMA;
this.procedures["entrega"] = entrega;
this.procedures["detector de gases"] = detector_de_gases;
this.procedures["reiniciar1"] = reiniciar1;
this.procedures["reiniciar2"] = reiniciar2;
this.procedures["movimiento"] = movimiento;

var PROC = {
    "cargado": cargado,
    "inicio": inicio2,
    "continuar": continuar,
    "pegatina": pegatina,
    "respiradores": respiradores,
    "FIRMA": FIRMA,
    "entrega": entrega,
    "detector de gases": detector_de_gases,
    "reiniciar1": reiniciar1,
    "reiniciar2": reiniciar2,
    "movimiento": movimiento,
};

var VARS = Object.defineProperties({}, {
    'i': { get: function() { return i; }, set: function(val) { i = val; } },
});

var i;

_pGlob.animMixerCallbacks = [];

const initAnimationMixer = function() {

    function onMixerFinished(e) {
        const cb = _pGlob.animMixerCallbacks;
        const found = [];
        for (let i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (let i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            PzLib.bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;

        let scene, frameRate, timeScale, callbacks;

        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();

                if (loop == 'AUTO') {
                    // COMPAT: < 4.10, old engine, new puzzles (no autoParams)
                    if (action.autoParams) {
                        action.loop = action.autoParams.loop;
                        action.repetitions = action.autoParams.repetitions;
                    } else {
                        action.repetitions = Infinity;
                    }
                } else {
                    action.loop = v3d[loop];
                    action.repetitions = Infinity;
                }

                scene = PzLib.getSceneByAction(action);
                frameRate = PzLib.getSceneAnimFrameRate(scene);
                timeScale = Math.abs(parseFloat(speed));

                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                callbacks = _pGlob.animMixerCallbacks;
                let found = false;
                for (let j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            callbacks = _pGlob.animMixerCallbacks;
            for (let j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--;
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            scene = PzLib.getSceneByAction(action);
            frameRate = PzLib.getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (let i = 0; i < animations.length; i++) {
        const animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// setCameraParam puzzle
function setCameraParam(type, camSelector, param) {

    const camNames = PzLib.retrieveObjectNames(camSelector);

    camNames.forEach(function(camName) {
        if (!camName)
            return;

        var cam = PzLib.getObjectByName(camName);
        if (!cam || !cam.isCamera) return;

        if (!(cam.isPerspectiveCamera || cam.isOrthographicCamera)) {
            console.error('set camera param puzzle: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        let isSetFirstpersonParam = false;

        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
            case 'SCREEN_SPACE_PANNING':
                isSetOrbitParam = true;
                break;
            case 'ENABLE_COLLISIONS':
                isSetFirstpersonParam = true;
                break;
        }

        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'ALLOW_CTRL_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam || isSetFirstpersonParam);

        if (isSetControlsParam) {
            if (!cam.controlSettings) {
                console.error('set camera param puzzle: The "' + camName +'" camera has no control settings assigned');
                return;
            } else if ((isSetOrbitParam && cam.controlSettings.type != 'ORBIT') ||
                    (isSetFirstpersonParam && cam.controlSettings.type != 'FIRST_PERSON')) {
                console.error('set camera param puzzle: Incompatible camera controls: ' + cam.controlSettings.type);
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (cam.isPerspectiveCamera) {
                    cam.fov = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (cam.isOrthographicCamera) {
                    cam.zoom = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                cam.controlSettings.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                cam.controlSettings.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                cam.controlSettings.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                cam.controlSettings.enableZoom = param;
                break;
            case 'ALLOW_CTRL_ZOOM':
                cam.controlSettings.enableCtrlZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                cam.controlSettings.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMinDistance = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMaxDistance = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMinZoom = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMaxZoom = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                cam.controlSettings.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                cam.controlSettings.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                cam.controlSettings.orbitEnableTurnover = param;
                break;
            case 'SCREEN_SPACE_PANNING':
                cam.controlSettings.screenSpacePanning = param;
                break;
            case 'ENABLE_COLLISIONS':
                cam.controlSettings.enableCollisions = param;
                break;
            case 'CLIP_START':
                cam.near = param;
                cam.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                cam.far = param;
                cam.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = PzLib.transformCoordsSpace(worldPos,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = PzLib.getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = PzLib.transformCoordsSpace(worldTarget,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = PzLib.getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// Describe this function...
function cargado() {
    tweenCamera('inicio', 'Cartel1.001', 1, function() {}, 1);
}

// autoRotateCamera puzzle
function autoRotateCamera(enabled, speed) {

    if (appInstance.controls && appInstance.controls instanceof v3d.OrbitControls) {
        appInstance.controls.autoRotate = enabled;
        appInstance.controls.autoRotateSpeed = speed;
    } else {
        console.error('autorotate camera puzzle: Wrong controls type');
    }
}

// Describe this function...
function inicio2() {
    registerSetTimeout(1, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Hola, bienvenido!","../../resources/audio/bienvenido.wav",false);')(appInstance, v3d, PL, VARS, PROC);

        registerSetTimeout(4, function() {

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Esta es la entrada de la planta.","../../resources/audio/bienvenido2.wav",false);')(appInstance, v3d, PL, VARS, PROC);

            operateAnimation('PLAY', 'NPC1', 0, 30, 'AUTO', 0.7, function() {}, false);
            tweenCamera('inicio', 'inicio_dir', 1, function() {
                i = 0;
                movimiento();
                registerSetTimeout(4, function() {

                    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Esta planta procesa uno de los metales más valiosos del mundo. También maneja tres de las sustancias más peligrosas que existen en minería. En los próximos 30 minutos vas a recorrerla antes de poner un pie dentro. Lo que aprendas aquí podría ser la diferencia.","../../resources/audio/a.wav",false);')(appInstance, v3d, PL, VARS, PROC);

                    registerSetTimeout(12, function() {
                        tweenCamera('ropa', 'Camisa', 4, function() {
                            registerSetTimeout(4, function() {
                                autoRotateCamera(true, 2);

                                Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Antes de proceder con el acceso, es fundamental asegurarnos de que contamos con el equipo de protección reglamentario.","../../resources/audio/b1.wav",false);')(appInstance, v3d, PL, VARS, PROC);

                                registerSetTimeout(8, function() {

                                    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Validar nuestras herramientas no es solo un protocolo, es la garantía de una operación segura.","../../resources/audio/b2.wav");')(appInstance, v3d, PL, VARS, PROC);

                                    registerSetTimeout(8, function() {

                                        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("¿Comenzamos?.","../../resources/audio/comenzamos.wav",false);')(appInstance, v3d, PL, VARS, PROC);

                                        autoRotateCamera(true, 0.5);
                                        registerSetTimeout(2, function() {

                                            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'inicio();')(appInstance, v3d, PL, VARS, PROC);

                                            autoRotateCamera(false, 0.5);
                                            tweenCamera('ropa', 'Camisa', 1, function() {
                                                setCameraParam('CLIP_END', 'Camera', 35);
                                            }, 1);
                                        });
                                    });
                                });
                            });
                        }, 1);
                    });
                });
            }, 1);
        });
    });
}

// Describe this function...
function continuar() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('aparecerObj();' + '\n' +
    'ocultar("stiker");')))(appInstance, v3d, PL, VARS, PROC);

    tweenCamera('ropa', 'Camisa', 1, function() {
        setCameraParam('CLIP_END', 'Camera', 50);

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Bien. Ahora necesito ver tu sticker de autorización en el casco.","../../resources/audio/c.wav");')(appInstance, v3d, PL, VARS, PROC);

        registerSetTimeout(3, function() {

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/equipo/pegatina.png");')(appInstance, v3d, PL, VARS, PROC);

        });
    }, 1);
}

// Describe this function...
function pegatina() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'mostrar("stiker");')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Para ingresar a la Planta de Molibdeno, es obligatorio asistir y aprobar el curso de inducción con una nota mínima del 90%. ","../../resources/audio/d1.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(11, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Una vez autorizado, debes portar en la parte posterior de tu casco el sticker oficial que te acredita como personal autorizado. Asimismo, el ingreso requiere el uso estricto de EPP básico, detector de gases portátil y protección respiratoria.","../../resources/audio/d2.wav",false);')(appInstance, v3d, PL, VARS, PROC);

        registerSetTimeout(20, function() {

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Ahora, veamos cómo debes colocarte el respirador de forma adecuada para asegurar tu seguridad en planta.","../../resources/audio/e.wav",false);')(appInstance, v3d, PL, VARS, PROC);


            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('html("../../resources/video/respiradores.mp4");' + '\n' +
            '')))(appInstance, v3d, PL, VARS, PROC);

        });
    });
}

// Describe this function...
function respiradores() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/equipo/FIRMA.png");')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("¡Excelente! Para finalizar el proceso, solo queda completar el formato de ingreso oficial.","../../resources/audio/final.wav");')(appInstance, v3d, PL, VARS, PROC);

}

// Describe this function...
function FIRMA() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Una vez llenado, se te dará el detector de gases.","../../resources/audio/formulario.wav");')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/video/entrega.mp4");')(appInstance, v3d, PL, VARS, PROC);

}

// Describe this function...
function entrega() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Puedes interactuar con el modelo 3D.","../../resources/audio/g2.wav");')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(4, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Este es uno de los muchos equipos disponibles; cuenta con una pantalla integrada, luces de estado y botones de navegación.","../../resources/audio/g.wav");')(appInstance, v3d, PL, VARS, PROC);


        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../DetectorGases/detector de gases.html",true);')(appInstance, v3d, PL, VARS, PROC);

    });
}

// Describe this function...
function detector_de_gases() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("¡Excelente! Hemos terminado con la primera parte del interactivo.","../../resources/audio/final2.wav");')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(7, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("¿Deseas reiniciar o continuar con el siguiente interactivo?","../../resources/audio/final3.wav");')(appInstance, v3d, PL, VARS, PROC);

        registerSetTimeout(4, function() {

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'pregunta("reiniciar", "¿Reiniciar?", "Sí", "Continuar");')(appInstance, v3d, PL, VARS, PROC);

        });
    });
}

// Describe this function...
function reiniciar1() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Bien, repasamos entonces","../../resources/audio/M2/repasosi.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(5, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'location.reload();')(appInstance, v3d, PL, VARS, PROC);

    });
}

// Describe this function...
function reiniciar2() {
}

// applyObjLocalTransform puzzle
function applyObjLocalTransform(objSelector, mode, vector) {

    var objNames = PzLib.retrieveObjectNames(objSelector);
    var x = vector[0] || 0;
      var y = vector[1] || 0;
      var z = vector[2] || 0;

    var defValue = mode == "scale" ? 1 : 0;
    if (typeof x != "number") x = defValue;
    if (typeof y != "number") y = defValue;
    if (typeof z != "number") z = defValue;

    var coords = PzLib.transformCoordsSpace(_pGlob.vec3Tmp.set(x, y, z),
            PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT', mode == 'scale');

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName) continue;

        var obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        // don't transform values for cameras, their local space happens
        // to be the same as for Blender/Max cameras, bcz their different
        // rest orientation balances difference in coordinate systems
        var useTransformed = !obj.isCamera;
        var xVal = useTransformed ? coords.x : x;
        var yVal = useTransformed ? coords.y : y;
        var zVal = useTransformed ? coords.z : z;

        switch (mode) {
        case "position":
            if (_pGlob.xrSessionAcquired && obj.isCamera) {
                v3d.WebXRUtils.translateVRCamera(obj, _pGlob.AXIS_X, xVal);
                v3d.WebXRUtils.translateVRCamera(obj, _pGlob.AXIS_Y, yVal);
                v3d.WebXRUtils.translateVRCamera(obj, _pGlob.AXIS_Z, zVal);
            } else {
                obj.translateX(xVal);
                obj.translateY(yVal);
                obj.translateZ(zVal);
            }
            break;
        case "rotation":
            if (_pGlob.xrSessionAcquired && obj.isCamera) {
                v3d.WebXRUtils.rotateVRCamera(obj, _pGlob.AXIS_X, v3d.MathUtils.degToRad(xVal));
                v3d.WebXRUtils.rotateVRCamera(obj, _pGlob.AXIS_Y, v3d.MathUtils.degToRad(yVal));
                v3d.WebXRUtils.rotateVRCamera(obj, _pGlob.AXIS_Z, v3d.MathUtils.degToRad(zVal));
            } else {
                obj.rotateX(v3d.MathUtils.degToRad(xVal));
                obj.rotateY(v3d.MathUtils.degToRad(yVal));
                obj.rotateZ(v3d.MathUtils.degToRad(zVal));
            }
            break;
        case "scale":
            obj.scale.x *= xVal;
            obj.scale.y *= yVal;
            obj.scale.z *= zVal;
            break;
        }

        obj.updateWorldMatrix(false, true);
    }
}

// Describe this function...
function movimiento() {
    if (i == 70) {
    } else if (i == 69) {
        operateAnimation('STOP', 'NPC1', null, null, 'AUTO', 1, function() {}, false);
        operateAnimation('PLAY', 'NPC1', 75, 85, 'LoopOnce', 1, function() {
            operateAnimation('PLAY', 'NPC1', 100, 447, 'AUTO', 1, function() {
                tweenCamera('', 'Camisa', 1, function() {}, 0);
            }, false);
        }, false);
    } else {
        registerSetTimeout(0.05, function() {
            applyObjLocalTransform('NPC1', 'position', ['', 0.001, 0.05]);
            registerSetTimeout(0.05, function() {
                applyObjLocalTransform('NPC1', 'position', ['', 0.001, 0.05]);
                i = 1 + i;
                movimiento();
            });
        });
    }
}


    operateAnimation('STOP', 'NPC1', null, null, 'AUTO', 1, function() {}, false);
    setCameraParam('ALLOW_PANNING', 'Camera', false);
    setCameraParam('CLIP_END', 'Camera', 50);
    setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'Camera', 30);

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('window.app = app; ' + '\n' +
    'import("./imports.js");')))(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(1, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'v3d.puzzles.procedures["cargado"]();')(appInstance, v3d, PL, VARS, PROC);

    });



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
