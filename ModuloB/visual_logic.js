/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.11.0
 * Fri, 27 Feb 2026 16:33:57 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = new Map();
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();
_pGlob.css3Objects = new WeakMap();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function getSceneAnimFrameRate(scene) {
        if (scene && 'animFrameRate' in scene.userData) {
            return scene.userData.animFrameRate;
        }
        return 24;
    }
        
    function getSceneByAction(action) {
        const root = action.getRoot();
        let scene = root.type === 'Scene' ? root : null;
        root.traverseAncestors(ancObj => {
            if (ancObj.type === 'Scene') {
                scene = ancObj;
            }
        });
        return scene;
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        // COMPAT: <4.9.0, old engine, new puzzles
        const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable)
            objFound = _pGlob.objCache.get(objName);
    
        if (objFound && (isID ? objFound.uuid === objName : objFound.name === objName))
            return objFound;
    
        function findValidByName(obj, objName) {
            if ((isID ? obj.uuid === objName : obj.name === objName) && isObjectWorthProcessing(obj))
                return obj;
    
            for (let i = 0; i < obj.children.length; i++) {
                const child = obj.children[i];
                const object = findValidByName(child, objName);
                if (object !== null)
                    return object;
            }
    
            return null;
        }
    
        if (appInstance.scene) {
            objFound = findValidByName(appInstance.scene, objName);
            if (objFound && pGlobAvailable)
                _pGlob.objCache.set(objName, objFound);
        }
    
        return objFound;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function removeObject(obj, objName) {
        if (obj.isClippingPlaneObject)
            // COMPAT: < 4.10, new puzzles, old engine
            if (v3d.SceneUtils.removeClipPlanesFromMats)
                v3d.SceneUtils.removeClipPlanesFromMats(obj, appInstance.scene);
    
        obj.parent.remove(obj);
    
        // remove object and its children from cache
        _pGlob.objCache.delete(objName);
    
        obj.traverse(child => {
            _pGlob.objCache.delete(child.name);
        });
    }

    return {
        bindListener, getSceneAnimFrameRate, getSceneByAction, getObjectByName,
        retrieveObjectNames, transformCoordsSpace, getSceneCoordSystem, removeObject,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    
    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["cargado"] = cargado;
this.procedures["inicio"] = inicio;
this.procedures["puerta1"] = puerta1;
this.procedures["info"] = info;
this.procedures["info2"] = info2;
this.procedures["info3"] = info3;
this.procedures["lavado"] = lavado;
this.procedures["lavado2"] = lavado2;
this.procedures["cartel1"] = cartel1;
this.procedures["repasoA1"] = repasoA1;
this.procedures["repasoA2"] = repasoA2;
this.procedures["nahz"] = nahz;
this.procedures["riesgos"] = riesgos;
this.procedures["x"] = x;
this.procedures["repasoB1"] = repasoB1;
this.procedures["error1"] = error1;
this.procedures["errorquizz"] = errorquizz;
this.procedures["error2"] = error2;
this.procedures["error3"] = error3;
this.procedures["continuar3"] = continuar3;

var PROC = {
    "cargado": cargado,
    "inicio": inicio,
    "puerta1": puerta1,
    "info": info,
    "info2": info2,
    "info3": info3,
    "lavado": lavado,
    "lavado2": lavado2,
    "cartel1": cartel1,
    "repasoA1": repasoA1,
    "repasoA2": repasoA2,
    "nahz": nahz,
    "riesgos": riesgos,
    "x": x,
    "repasoB1": repasoB1,
    "error1": error1,
    "errorquizz": errorquizz,
    "error2": error2,
    "error3": error3,
    "continuar3": continuar3,
};

var VARS = Object.defineProperties({}, {
    'errores': { get: function() { return errores; }, set: function(val) { errores = val; } },
});

var errores;

_pGlob.animMixerCallbacks = [];

const initAnimationMixer = function() {

    function onMixerFinished(e) {
        const cb = _pGlob.animMixerCallbacks;
        const found = [];
        for (let i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (let i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            PzLib.bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;

        let scene, frameRate, timeScale, callbacks;

        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();

                if (loop == 'AUTO') {
                    // COMPAT: < 4.10, old engine, new puzzles (no autoParams)
                    if (action.autoParams) {
                        action.loop = action.autoParams.loop;
                        action.repetitions = action.autoParams.repetitions;
                    } else {
                        action.repetitions = Infinity;
                    }
                } else {
                    action.loop = v3d[loop];
                    action.repetitions = Infinity;
                }

                scene = PzLib.getSceneByAction(action);
                frameRate = PzLib.getSceneAnimFrameRate(scene);
                timeScale = Math.abs(parseFloat(speed));

                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                callbacks = _pGlob.animMixerCallbacks;
                let found = false;
                for (let j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            callbacks = _pGlob.animMixerCallbacks;
            for (let j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--;
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            scene = PzLib.getSceneByAction(action);
            frameRate = PzLib.getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (let i = 0; i < animations.length; i++) {
        const animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// setActiveCamera puzzle
function setActiveCamera(camName) {
    var camera = PzLib.getObjectByName(camName);
    if (!camera || !camera.isCamera || appInstance.getCamera() == camera)
        return;
    appInstance.setCamera(camera);
}

// setCameraParam puzzle
function setCameraParam(type, camSelector, param) {

    const camNames = PzLib.retrieveObjectNames(camSelector);

    camNames.forEach(function(camName) {
        if (!camName)
            return;

        var cam = PzLib.getObjectByName(camName);
        if (!cam || !cam.isCamera) return;

        if (!(cam.isPerspectiveCamera || cam.isOrthographicCamera)) {
            console.error('set camera param puzzle: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        let isSetFirstpersonParam = false;

        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
            case 'SCREEN_SPACE_PANNING':
                isSetOrbitParam = true;
                break;
            case 'ENABLE_COLLISIONS':
                isSetFirstpersonParam = true;
                break;
        }

        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'ALLOW_CTRL_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam || isSetFirstpersonParam);

        if (isSetControlsParam) {
            if (!cam.controlSettings) {
                console.error('set camera param puzzle: The "' + camName +'" camera has no control settings assigned');
                return;
            } else if ((isSetOrbitParam && cam.controlSettings.type != 'ORBIT') ||
                    (isSetFirstpersonParam && cam.controlSettings.type != 'FIRST_PERSON')) {
                console.error('set camera param puzzle: Incompatible camera controls: ' + cam.controlSettings.type);
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (cam.isPerspectiveCamera) {
                    cam.fov = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (cam.isOrthographicCamera) {
                    cam.zoom = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                cam.controlSettings.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                cam.controlSettings.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                cam.controlSettings.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                cam.controlSettings.enableZoom = param;
                break;
            case 'ALLOW_CTRL_ZOOM':
                cam.controlSettings.enableCtrlZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                cam.controlSettings.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMinDistance = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMaxDistance = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMinZoom = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMaxZoom = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                cam.controlSettings.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                cam.controlSettings.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                cam.controlSettings.orbitEnableTurnover = param;
                break;
            case 'SCREEN_SPACE_PANNING':
                cam.controlSettings.screenSpacePanning = param;
                break;
            case 'ENABLE_COLLISIONS':
                cam.controlSettings.enableCollisions = param;
                break;
            case 'CLIP_START':
                cam.near = param;
                cam.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                cam.far = param;
                cam.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// Describe this function...
function cargado() {
}

// autoRotateCamera puzzle
function autoRotateCamera(enabled, speed) {

    if (appInstance.controls && appInstance.controls instanceof v3d.OrbitControls) {
        appInstance.controls.autoRotate = enabled;
        appInstance.controls.autoRotateSpeed = speed;
    } else {
        console.error('autorotate camera puzzle: Wrong controls type');
    }
}

// Describe this function...
function inicio() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'caminoflecha(["inicio", "inicio2", "inicio3"],"inicio");')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'camino(["inicio", "inicio2", "inicio3"],"inicio");')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Hola de nuevo!","../../resources/audio/M2/bienvenido.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(3, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Ahora veremos las sustancias químicas en la planta de molibdeno.","../../resources/audio/M2/a.wav",false);')(appInstance, v3d, PL, VARS, PROC);

        registerSetTimeout(6, function() {

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Toda sustancia química que ingresa a las instalaciones de Anglo American es evaluada por la Gerencia de Medio Ambiente y la Gerencia de Salud y Seguridad (Higiene Industrial y Respuesta de Emergencias).","../../resources/audio/M2/b1.wav",false);')(appInstance, v3d, PL, VARS, PROC);

            registerSetTimeout(13, function() {

                Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Solo la aprobación de las HDS/MSDS de la sustancia química permite su uso en nuestra operación.","../../resources/audio/M2/b2.wav",false);')(appInstance, v3d, PL, VARS, PROC);


                Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/M2/info.png");')(appInstance, v3d, PL, VARS, PROC);

                autoRotateCamera(false, 2);
            });
        });
    });
}

// Describe this function...
function puerta1() {
    cartel1();
}

// Describe this function...
function info() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Secciones Críticas de la FDS","../../resources/audio/M2/d.wav",false);')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/M2/info2.png");')(appInstance, v3d, PL, VARS, PROC);

}

// Describe this function...
function info2() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("...","../../resources/audio/M2/e.wav",false);')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/M2/info3.png");')(appInstance, v3d, PL, VARS, PROC);

}

// outline puzzle
function outline(objSelector, doWhat) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
    var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        if (doWhat == "ENABLE") {
            if (outlineArray.indexOf(obj) == -1)
                outlineArray.push(obj);
        } else {
            var index = outlineArray.indexOf(obj);
            if (index > -1)
                outlineArray.splice(index, 1);
        }
    }
}

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = PzLib.transformCoordsSpace(worldPos,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = PzLib.getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = PzLib.transformCoordsSpace(worldTarget,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = PzLib.getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// Describe this function...
function info3() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Este es el sistema de lavado de gases.","../../resources/audio/M2/f.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    setActiveCamera('Camera');
    tweenCamera('lavadoGases', 'Cartel1', 1, function() {
        registerSetTimeout(2.5, function() {

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("¿Qué te parece?","../../resources/audio/M2/f2.wav",false);')(appInstance, v3d, PL, VARS, PROC);

            outline('lavtubo', 'ENABLE');
            registerSetTimeout(3, function() {

                Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Así se ve en persona.","../../resources/audio/M2/f3.wav",false);')(appInstance, v3d, PL, VARS, PROC);


                Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/M2/lavado.png");')(appInstance, v3d, PL, VARS, PROC);

            });
        });
    }, 1);
}

// Describe this function...
function lavado() {
    outline(['ALL_OBJECTS'], 'DISABLE');

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("¿Por qué son clave los lavadores de gases?","../../resources/audio/M2/f4.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    setActiveCamera('1per');
    registerSetTimeout(1, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('camino(["inicio", "inicio2", "inicio3"],"inicio3");' + '\n' +
        '')))(appInstance, v3d, PL, VARS, PROC);

        registerSetTimeout(4, function() {

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Porque no solo reducen las emisiones contaminantes y aseguran el cumplimiento de las normas ambientales, sino que son fundamentales para proteger la salud de las personas y preservar nuestro entorno.","../../resources/audio/M2/f5.wav",false);')(appInstance, v3d, PL, VARS, PROC);


            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/M2/lavado2.png");')(appInstance, v3d, PL, VARS, PROC);


            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'camino(["inicio", "inicio2", "inicio3"],"inicio3");')(appInstance, v3d, PL, VARS, PROC);

        });
    });
}

// Describe this function...
function lavado2() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("No olvides consultar los carteles informativos.","../../resources/audio/M2/gx.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    tweenCamera('', 'polySurface1105', 1, function() {}, 0);

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/M2/cartel1.png");')(appInstance, v3d, PL, VARS, PROC);

    outline('polySurface1105', 'ENABLE');
}

// Describe this function...
function cartel1() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("¿Quieres dar un repaso al sistema de lavado de gases?","../../resources/audio/M2/repaso1.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(5, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'pregunta("repasoA", "¿Repaso?", "Sí", "No");')(appInstance, v3d, PL, VARS, PROC);

    });
}

// Describe this function...
function repasoA1() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Bien, repasamos entonces","../../resources/audio/M2/repasosi.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(4, function() {
        inicio();
    });
}

// Describe this function...
function repasoA2() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'humo("pCylinder206", "#2bbf24", 0.5, 30, 5.8, 0.2, 0.9, "arriba");')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Bueno, continuamos","../../resources/audio/M2/repasono.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(4, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Bueno, ahora echemos un ojo a la planta de hidrosulfuro de sodio.","../../resources/audio/M2/h.wav",false);')(appInstance, v3d, PL, VARS, PROC);

        registerSetTimeout(6, function() {

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'caminoflecha(["inicio", "inicio2", "inicio3","inicio4","inicio5","inicio6"],"inicio5");')(appInstance, v3d, PL, VARS, PROC);


            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Vamos","../../resources/audio/M2/h2.wav",false);')(appInstance, v3d, PL, VARS, PROC);


            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'camino(["inicio", "inicio2", "inicio3","inicio4","inicio5","inicio6"],"inicio5");')(appInstance, v3d, PL, VARS, PROC);

            registerSetTimeout(3, function() {

                Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Así se ve en persona.","../../resources/audio/M2/f3.wav",false);')(appInstance, v3d, PL, VARS, PROC);


                Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/M2/nahz.png");')(appInstance, v3d, PL, VARS, PROC);

            });
        });
    });
}

// Describe this function...
function nahz() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("¿Qué te parece?","../../resources/audio/M2/f2.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(2, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("...","../../resources/audio/M2/i.wav");')(appInstance, v3d, PL, VARS, PROC);


        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'html("../../resources/img/M2/riesgos.png");')(appInstance, v3d, PL, VARS, PROC);

    });
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// Describe this function...
function riesgos() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Listo. Antes de continuar, necesito que identifiques los tres errores que no deberían estar presentes","../../resources/audio/M2/j.wav");')(appInstance, v3d, PL, VARS, PROC);

    errorquizz();
    changeVis(['ALL_OBJECTS'], true);
}

// Describe this function...
function x() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("¿Quieres dar un repaso a los tanques de hidrosulfuro de sodio?","../../resources/audio/M2/repaso2.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(5, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'pregunta("repasoB", "¿Repaso?", "Sí", "No");')(appInstance, v3d, PL, VARS, PROC);

    });
}

// Describe this function...
function repasoB1() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Bien, repasamos entonces","../../resources/audio/M2/repasosi.wav",false);')(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(5, function() {
        repasoA2();
    });
}

// Describe this function...
function error1() {
    errores = 1 + errores;
    changeVis('error1', false);

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'humosx();')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('avatar("Presencia de líquido amarillento con emanación de olor sulfuroso. Posible presencia de H_2S.",' + '\n' +
    '"../../resources/audio/M2/error1.wav");')))(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(2, function() {});
}

// Describe this function...
function errorquizz() {
    if (errores == 4) {
    } else if (errores == 3) {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Excelente","../../resources/audio/M2/exelente.wav");')(appInstance, v3d, PL, VARS, PROC);

        registerSetTimeout(2, function() {

            Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'avatar("Encontraste todos los errores; puedes continuar.","../../resources/audio/M2/errorquizz.wav");')(appInstance, v3d, PL, VARS, PROC);

            continuar3();
        });
    } else if (errores == 2) {
    } else {
        registerSetTimeout(0.2, function() {
            errorquizz();
        });
    }
}

// removeObject puzzles
function removeObject(objSelector) {
    const objNames = PzLib.retrieveObjectNames(objSelector);

    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i]
        if (!objName)
            continue;
        const obj = PzLib.getObjectByName(objName);
        if (!obj || !obj.parent)
            continue;

        PzLib.removeObject(obj, objName);

        if (_pGlob.css3Objects.has(obj)) {
            const cssObj = _pGlob.css3Objects.get(obj);
            PzLib.removeObject(cssObj, cssObj.name);
            _pGlob.css3Objects.delete(obj);
        }
    }
}

// Describe this function...
function error2() {
    errores = 1 + errores;
    changeVis('error2', false);
    removeObject('botella');

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('avatar("Botella de agua abierta cerca del área. El ácido reacciona violentamente con el agua.",' + '\n' +
    '"../../resources/audio/M2/error2.wav");')))(appInstance, v3d, PL, VARS, PROC);

}

// Describe this function...
function error3() {
    errores = 1 + errores;
    changeVis('error3', false);
    removeObject('Armature');

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('avatar("¡Bien! El trabajador está sin protección respiratoria; no debería estar sin ella.",' + '\n' +
    '"../../resources/audio/M2/error3.wav");')))(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(2, function() {});
}

// Describe this function...
function continuar3() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('caminoflecha([' + '\n' +
    '  "inicio", ' + '\n' +
    '  "inicio2", ' + '\n' +
    '  "inicio3",' + '\n' +
    '  "inicio4",' + '\n' +
    '  "inicio5",' + '\n' +
    '  "inicio6",' + '\n' +
    '  "inicio7",' + '\n' +
    '  "inicio8",' + '\n' +
    '  "inicio9"' + '\n' +
    '], "inicio9");')))(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('camino([' + '\n' +
    '  "inicio", ' + '\n' +
    '  "inicio2", ' + '\n' +
    '  "inicio3",' + '\n' +
    '  "inicio4",' + '\n' +
    '  "inicio5",' + '\n' +
    '  "inicio6",' + '\n' +
    '  "inicio7",' + '\n' +
    '  "inicio8",' + '\n' +
    '  "inicio9"' + '\n' +
    '], "inicio9");')))(appInstance, v3d, PL, VARS, PROC);

}


    operateAnimation('STOP', 'Puerta1', null, null, 'AUTO', 1, function() {}, false);
    operateAnimation('STOP', 'Puerta2', null, null, 'AUTO', 1, function() {}, false);
    setActiveCamera('1per');
    setCameraParam('ENABLE_COLLISIONS', '1per', true);
    setCameraParam('ALLOW_ZOOM', '1per', false);
    setCameraParam('ALLOW_PANNING', 'Camera', false);
    setCameraParam('KEYBOARD_CONTROLS', '1per', false);
    setCameraParam('KEYBOARD_CONTROLS', 'Camera', false);
    setCameraParam('CLIP_END', '1per', 40);
    setCameraParam('CLIP_END', 'Camera', 50);
    setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'Camera', 30);

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('window.app = app; ' + '\n' +
    'import("./imports.js");')))(appInstance, v3d, PL, VARS, PROC);

    registerSetTimeout(1, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'v3d.puzzles.procedures["cargado"]();')(appInstance, v3d, PL, VARS, PROC);

    });

    errores = 0;
    changeVis('error1', false);
    changeVis('error2', false);
    changeVis('error3', false);



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
