/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.11.0
 * Thu, 26 Feb 2026 02:21:16 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = new Map();
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();
_pGlob.css3Objects = new WeakMap();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function isObjectWorthProcessing(obj) {
        return obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        // COMPAT: <4.9.0, old engine, new puzzles
        const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable)
            objFound = _pGlob.objCache.get(objName);
    
        if (objFound && (isID ? objFound.uuid === objName : objFound.name === objName))
            return objFound;
    
        function findValidByName(obj, objName) {
            if ((isID ? obj.uuid === objName : obj.name === objName) && isObjectWorthProcessing(obj))
                return obj;
    
            for (let i = 0; i < obj.children.length; i++) {
                const child = obj.children[i];
                const object = findValidByName(child, objName);
                if (object !== null)
                    return object;
            }
    
            return null;
        }
    
        if (appInstance.scene) {
            objFound = findValidByName(appInstance.scene, objName);
            if (objFound && pGlobAvailable)
                _pGlob.objCache.set(objName, objFound);
        }
    
        return objFound;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }

    return {
        getObjectByName, retrieveObjectNames,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = true;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = false;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["a"] = a;

var PROC = {
    "a": a,
};

var VARS = Object.defineProperties({}, {
    
});

// setCameraParam puzzle
function setCameraParam(type, camSelector, param) {

    const camNames = PzLib.retrieveObjectNames(camSelector);

    camNames.forEach(function(camName) {
        if (!camName)
            return;

        var cam = PzLib.getObjectByName(camName);
        if (!cam || !cam.isCamera) return;

        if (!(cam.isPerspectiveCamera || cam.isOrthographicCamera)) {
            console.error('set camera param puzzle: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        let isSetFirstpersonParam = false;

        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
            case 'SCREEN_SPACE_PANNING':
                isSetOrbitParam = true;
                break;
            case 'ENABLE_COLLISIONS':
                isSetFirstpersonParam = true;
                break;
        }

        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'ALLOW_CTRL_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam || isSetFirstpersonParam);

        if (isSetControlsParam) {
            if (!cam.controlSettings) {
                console.error('set camera param puzzle: The "' + camName +'" camera has no control settings assigned');
                return;
            } else if ((isSetOrbitParam && cam.controlSettings.type != 'ORBIT') ||
                    (isSetFirstpersonParam && cam.controlSettings.type != 'FIRST_PERSON')) {
                console.error('set camera param puzzle: Incompatible camera controls: ' + cam.controlSettings.type);
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (cam.isPerspectiveCamera) {
                    cam.fov = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (cam.isOrthographicCamera) {
                    cam.zoom = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                cam.controlSettings.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                cam.controlSettings.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                cam.controlSettings.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                cam.controlSettings.enableZoom = param;
                break;
            case 'ALLOW_CTRL_ZOOM':
                cam.controlSettings.enableCtrlZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                cam.controlSettings.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMinDistance = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMaxDistance = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMinZoom = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMaxZoom = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                cam.controlSettings.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                cam.controlSettings.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                cam.controlSettings.orbitEnableTurnover = param;
                break;
            case 'SCREEN_SPACE_PANNING':
                cam.controlSettings.screenSpacePanning = param;
                break;
            case 'ENABLE_COLLISIONS':
                cam.controlSettings.enableCollisions = param;
                break;
            case 'CLIP_START':
                cam.near = param;
                cam.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                cam.far = param;
                cam.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

// autoRotateCamera puzzle
function autoRotateCamera(enabled, speed) {

    if (appInstance.controls && appInstance.controls instanceof v3d.OrbitControls) {
        appInstance.controls.autoRotate = enabled;
        appInstance.controls.autoRotateSpeed = speed;
    } else {
        console.error('autorotate camera puzzle: Wrong controls type');
    }
}

// zoomCamera puzzle
function zoomCamera(objSelector, duration, doSlot) {

    duration = Math.max(0, duration);

    const objNames = PzLib.retrieveObjectNames(objSelector);

    const zoomObjects = [];
    objNames.forEach(function(name) {
        const obj = PzLib.getObjectByName(name);
        if (obj) {
            zoomObjects.push(obj);
        }
    });

    if (!zoomObjects.length) {
        return;
    }

    const camera = appInstance.getCamera();

    const zoom = [camera.zoom]; // for orthographic camera only

    const pos = _pGlob.vec3Tmp, target = _pGlob.vec3Tmp2;
    v3d.CameraUtils.calcCameraZoomToObjectsParams(camera, zoomObjects,
            pos, target, zoom);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            if (camera.isOrthographicCamera) {
                appInstance.controls.tweenZoomTo(target, zoom[0],
                        duration, doSlot);
            } else {
                appInstance.controls.tween(pos, target, duration, doSlot);
            }
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(pos);
        }
        camera.position.copy(pos);
        camera.lookAt(target);
        camera.zoom = zoom[0];
        camera.updateProjectionMatrix();
        doSlot();
    }
}

// setLightParam puzzle
function setLightParam(type, objSelector, param) {

    if (type === 'SHADOW_MAP_FILTERING') {
        const rendererShadowMap = appInstance.renderer.shadowMap;
        if (rendererShadowMap) {
            let shadowMapFilteringTypeBefore = rendererShadowMap.type;

            switch (param) {
                case 'BASIC':
                    rendererShadowMap.type = v3d.BasicShadowMap;
                    break;
                case 'BILINEAR':
                    rendererShadowMap.type = v3d.BilinearShadowMap;
                    break;
                case 'PCF':
                // COMPAT: deprecated, PCF == v3d.PCFShadowMapPoissonDisk since 4.7
                case 'PCFBILINEAR':
                case 'PCFPOISSON':
                    // TODO: PCF == v3d.PCFShadow since 4.8
                    rendererShadowMap.type = v3d.PCFShadowMapPoissonDisk;
                    break;
                case 'ESM':
                    rendererShadowMap.type = v3d.ESMShadowMap;
                    break;
                default:
                    console.error('set light param puzzle: Incompatible shadow map filtering type.')
                    return;
                    break;
            }

            if (shadowMapFilteringTypeBefore != rendererShadowMap.type) {

                let deleteShadowMapFromObj = function(object) {
                    if (!object.shadow) return;

                    if (object.shadow.isDirectionalLightShadowCSM) {
                        object.shadow.updateMaps();

                    } else if (object.shadow) {
                        object.shadow.dispose();
                        // COMPAT: < 4.10
                        if (object.shadow.removeMaps) {
                            object.shadow.removeMaps();
                        } else {
                            object.shadow.map = null;
                            object.shadow._additionalMap2D = null;
                            object.shadow._additionalMapCube = null;
                        }
                    }
                }

                // need to update shadow.map for ESM filtering
                let needToUpdateShadowMaps = shadowMapFilteringTypeBefore == v3d.ESMShadowMap ||
                        rendererShadowMap.type == v3d.ESMShadowMap;
                const compiled = {};
                appInstance.scene.traverse(function(object) {

                    const material = object.material;
                    if (material && object.receiveShadow) {

                        if (Array.isArray(material)) {
                            for (let i = 0; i < material.length; i++) {
                                const material2 = material[i];

                                if (material2.uuid in compiled === false) {
                                    material2.needsUpdate = true;
                                    compiled[material2.uuid] = true;
                                }

                            }

                        } else if (material.uuid in compiled === false) {
                            material.needsUpdate = true;
                            compiled[material.uuid] = true;

                        }
                    }

                    if (needToUpdateShadowMaps)
                        deleteShadowMapFromObj(object);
                });
            }

        }
        return;
    }

    const objNames = PzLib.retrieveObjectNames(objSelector);

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        const obj = PzLib.getObjectByName(objName);
        if (!obj || !obj.isLight)
            return;

        switch (type) {
        case 'COLOR_VECTOR':
            obj.color.r = param[0];
            obj.color.g = param[1];
            obj.color.b = param[2];
            break;
        case 'COLOR_CSS_HEX':
        case 'COLOR_CSS_RGB':
            const color = _pGlob.colorTmp.set(param);
            obj.color.r = color.r;
            obj.color.g = color.g;
            obj.color.b = color.b;
            break;
        case 'INTENSITY':
            if (obj.userData.usePowerUnits)
                obj.power = param;
            else
                obj.intensity = param;
            break;
        case 'USE_SHADOW':
            if (obj.isAmbientLight) {
                console.error('set light param puzzle: Incompatible light source');
                return;
            }
            if (typeof(param) === "boolean")
                obj.castShadow = param;

            break;
        case 'SHADOW_MAP_SIZE':
            if (obj.isAmbientLight) {
                console.error('set light param puzzle: Incompatible light source');
                return;
            }

            if (!obj.shadow) return;

            if (obj.shadow.isDirectionalLightShadowCSM) {
                obj.shadow.mapSize.set(param, param);
                obj.shadow.updateMapSize();

            } else if (obj.shadow) {
                obj.shadow.mapSize.set(param, param);
                obj.shadow.dispose();
                // COMPAT: < 4.10
                if (obj.shadow.removeMaps) {
                    obj.shadow.removeMaps();
                } else {
                    obj.shadow.map = null;
                    obj.shadow._additionalMap2D = null;
                    obj.shadow._additionalMapCube = null;
                }
            }

            break;
        }

    });

}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// Describe this function...
function a() {
    setLightParam('INTENSITY', ['ALL_OBJECTS'], 30);
    registerSetTimeout(1, function() {
        setLightParam('INTENSITY', ['ALL_OBJECTS'], 0);
        setLightParam('INTENSITY', 'Point.002', 30);
        registerSetTimeout(0.8, function() {
            a();
        });
    });
}



    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('// 1. Definimos el objeto global' + '\n' +
    'window.app = app; ' + '\n' +
    '' + '\n' +
    '// 2. Importamos el archivo y esperamos a que termine' + '\n' +
    'import("./imports.js");')))(appInstance, v3d, PL, VARS, PROC);

    setCameraParam('ALLOW_PANNING', 'Camera', false);
    setCameraParam('ALLOW_ZOOM', 'Camera', false);
    zoomCamera('detector', 1, function() {
        autoRotateCamera(true, 1);
    });
    a();



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
